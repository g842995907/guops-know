#### a=b 赋值

```python
a = [1,2,"hello",['python', 'C++']]
b = a
b is a
True
```

在上述情况下,a 和 b 是一样的,他们指向同一片内存,b 不过是 a 的别名,是引用。
  我们可以使用 b is a 去判断,返回 True,表明他们地址相同,内容相同;
赋值操作(包括对象作为参数、返回值)不会开辟新的内存空间,它只是**复制了对象的引用**。也就是
说除了 b 这个名字之外,没有其他的内存开销。修改了 a,也就影响了 b,同理,修改了 b,也就影响
了 a。

#### 浅拷贝

浅拷贝会创建新对象,其内容非原对象本身的引用,而是**原对象内第一层对象的引用**。(如果原对象第一层是一个可变类型的话,那么他就会重新开辟一个内存空间,不可变类型则不会开辟新的内存空间,里面的继续使用原对象里面的引用) 

1, 其中如果里面引用是一个不可变类型也是会直接指向,如果是可变类型同样指向可变类型的空间地址

2, 当可变类型里面的内容添加,但是并没有改变其空间地址的时候, 浅拷贝会跟着原来数据变化而变化;

****

```python
import copy
a = [1,2,[3,4]]
b = copy.copy(a)
b is a
False
a[0] = 3
a: [3,2,[3,4]]
b: [1, 2, [3, 4]]

a[2].append(5)
a: [1, 2, [3, 4, 5]]
b: [1, 2, [3, 4, 5]]

# 其中浅拷贝有
# 列表 中的
b = a[:]
b = [i for i in a]
b = list(a)
b = copy.copy(a)

# 字典
c = {'a':1}
d = c.copy()
```

当最外层对象是一个不可变类型的时候 浅拷贝就不会开辟新的空间 而是引用之前的对象的引用

```python
a = (1, 2, [3, 4])
b = a[:]
b is a
True
```

#### 3 深拷贝

深拷贝和浅拷贝对应,深拷贝拷贝了**对象的所有元素**,包括多层嵌套的元素。因此,它的时间和空
间开销要高。

同样的对列表 a,如果使用 b = copy.deepcopy(a),再修改列表 b 将不会影响到列表 a,即使嵌
套的列表具有更深的层次,也不会产生任何影响,因为深拷贝拷贝出来的对象根本就是一个全新的对象,
不再与原来的对象有任何的关联。

```python
a = (1, 2, [3, 4, 5, 6])

b = copy.deepcopy(a)
b is a
False

# 原对象操作和先对象没有任何关系
a[2].append(5)
(1, 2, [3, 4, 5, 6, 5])

b
(1, 2, [3, 4, 5, 6])
```

#### 4 拷贝注意点

对于非容器类型,如数字、字符,以及其他的“原子”类型,没有拷贝一说,产生的都是原对象的
引用。
如果元组变量值包含原子类型对象,即使采用了深拷贝,也只能得到浅拷贝;

就是都是不可变类型的时候就是不存在浅拷贝

```python
a = (1,2,901,(3,4))
b = copy.deepcopy(a)
a is b
True
```



