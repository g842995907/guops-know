## 冒泡排序

- **比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。**

- **对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。**

- 针对所有的元素重复以上的步骤，除了最后一个。

- 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

  ```python
  def buttet_sort(list):
      n = len(list)
      for i in range(n-1):
          count = 0
          for j in range(n-1-i):
              if list[j] > list[j + 1]:
                  list[j], list[j + 1] = list[j + 1], list[j]
                  count += 1
          if count == 0:
             break
  li = [54,26,93,17,77,31,44,55,20]
  buttet_sort(li)
  ```

## **时间复杂度**

- 最优时间复杂度：O(n) （表示遍历一次发现没有任何可以交换的元素，排序结束。）
- 最坏时间复杂度：O(n2)
- 稳定性：稳定